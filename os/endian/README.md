大端字节序与小端字节序
===

<!-- TOC -->

- [定义](#定义)
- [现状](#现状)
- [为什么有这样的问题](#为什么有这样的问题)
- [相关问题](#相关问题)
	- [字节序判断](#字节序判断)
	- [网络字节序转主机字节序](#网络字节序转主机字节序)

<!-- /TOC -->
## 定义

字节序处理的问题是:**低位地址应该先存高位字节还是低位字节**.

* 大端字节序  
  先存高位字节.
* 小端字节序  
  先存低位字节.

![](big-little-endianess.gif)

## 现状

* Intel的80×86系列芯片使用小端存储模式
* ARM芯片默认采用小端，但可以切换为大端
* MIPS芯片采用大端，但可以在大小端之间切换
* 在网络上传输的数据普遍采用的都是大端

## 为什么有这样的问题

主要是考虑CPU.CPU取一个占好几个字节的数时,如果采用大端字节序,可以在第一个字节出判断出正负;如果采用小端字节序,可以很快的完成加减乘除运算,因为他们都是从地位开始运算的.

这样就产生了分歧,有的CPU看中后者,比如Intel x86;有的看中前者,比如MIPS芯片.

另外,大端字节序也方便人阅读和处理,网络字节序就采用了大端模式.

## 相关问题

先面介绍两个相关的问题.

### 字节序判断

直接判断```int x=1;```的最高位字节即可.

可以采用union,也可以直接取地址内容实现.

### 网络字节序转主机字节序


linux提供一系列的API:  
* htons,htonl
* ntohs,ntohl

