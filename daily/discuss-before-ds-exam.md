# 数据结构整理    

  * **数据结构的定义**
    * 时间复杂度  
    * 空间复杂度
    * 其他性能(如排序的稳定性，查找的平均查找长度，编码的期望长度)  
  * **线性表**
    * 顺序实现
    * 链式实现  
      * 单向链表
      * 循环链表
      * 双向链表
  * **栈和队列**  
      * FIFO
      * LIFO
  * **串**
    * 基本定义
    * 块链存储(可用于共享后缀)
    * 模式匹配(KMP)
  * **数组和广义表**
    * 矩阵压缩
    * 广义表(递归定义)
  * **树和二叉树**
    * 基本定义(子树，深度，层次，兄弟节点，度)
    * 二叉树(满二叉树，完全二叉树，计算问题)
    * 二叉树的遍历、线索化
    * 树和森林的转化
    * Huffman树(最优二叉树，前缀编码)
  * **图**
    * 基本定义($G=(V,E)$，关联联接，连通分量，回路，权重，出度，入度)
    * 基本操作(DFS,BFS)
    * 连通性问题
      * 无向图的连通分量和生成树(关注定义)
      * 有向图的强连通强连通分量(连通分量和强连通分量的区别)
      * 最小生成树(定义，不唯一性)
      * 关节点和重连通分量(教材上打了星号，好像不考，了解就行)
    * 有向无环图(拓扑排序，关键路径，关键活动)
    * 最短路径问题(Dijkstra,Floyd,及其他算法)
  * **查找**
    * 基本定义(主关键字，次关键字，ASL)
    * 静态查找(顺序表、有序表，非等概率查找，分块查找)
    * 动态查找(BST的删除操作,平衡二叉树的平衡因子、旋转操作,键树)
    * 哈希表(哈希函数的构造方法,线性探测，再哈希，链地址法)


  * **内部排序**
    * 定义(稳定性，非比较型排序)
    * 插入排序(直接插入，2路插入，折半插入，**希尔排序**)
      * 道听途说的评价  
      插入排序比较直观，但是总会有移动带来的负担;  希尔排序就是通过增加移动距离来优化的,具体性能取决与增量序列(增量序列的尾部必须为1)  
      据说[希尔排序是最早一批性能突破 $O(n^2)$ 的排序算法](http://blog.csdn.net/lemon_tree12138/article/details/51127533)
    * 快速排序
      * 基本思想(给每个**枢轴**找到正确位置,时间复杂度为 $O(nlog_2n)$)
      * 快排的性能非常好，很多编程语言都内置快排算法(C语言的```qsort()```,C++的```sort()```等，也有的说是各种排序混合在一起用)
    * 选择排序(简单选择，树形选择，堆排序)
      * 堆排序是个很神奇的排序，把线性表和二叉树结合，反复建堆来完成排序,总复杂度不超过 $nlog_2n$
      * 堆排序看起来可以和快速排序媲美，其实很比较，说什么的都有,这里给出几个参考  
      [知乎一](https://www.zhihu.com/question/20842649)  
      [知乎二](https://www.zhihu.com/question/23873747)  
      [刘未鹏的博客](http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/)
    * 归并排序
        * 主要把集合分散开来分别排序，最终合并。可以很好的和分布式计算结合。
        * 时间复杂度: $nlog_2n$
        * 空间复杂度: $O(n)$,这一点不如其他算法
    * 基数排序
        * 思想：多关键字下元素的分离和收集
        * 从带排序元素中抽出多个关键字，每次利用一个关键字使集合部分有序，最终完成排序。
        * 为了保证排序稳定，对关键字排序时必须使用稳定的排序方法，但为了方便一般使用分离和收集的方法。
    * 各种内部排序的比较  


     排序方法| 平均时间| 最坏情况 |辅助存储|
     ------------- |:-------------:| -----:|-----|
     简单排序      | O(n^2)  |  O(n^2)  | O(1) |
     快速排序      |  O(nlog_2n)  |    O(n^2)   | O(logn) |
     堆排序 |  O(nlog_2n)       |     O(nlog_2n)   | O(1) |
     归并排序 |  O(nlog_2n)       | O(nlog_2n)      | O(n) |
     基数排序 |  O(d(n+rd))      |     O(d(n+rd))  | O(rd) |
