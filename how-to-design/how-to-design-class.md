<!-- TOC -->

- [1. 如何抽象出ADT](#1-如何抽象出adt)
    - [1.1. 隐藏并集中化实现细节](#11-隐藏并集中化实现细节)
    - [1.2. 区分底层概念和现实意义](#12-区分底层概念和现实意义)
    - [1.3. 减少和其他ADT的关联](#13-减少和其他adt的关联)
- [2. 如何设计好接口](#2-如何设计好接口)
    - [2.1. 接口的抽象层次应该一致](#21-接口的抽象层次应该一致)
    - [2.2. 严格控制成员的可访问性](#22-严格控制成员的可访问性)
    - [2.3. 不要假设接口的调用顺序](#23-不要假设接口的调用顺序)
- [3. 如何设计好成员对象](#3-如何设计好成员对象)
    - [3.1. 数据成员应该限制在7个左右](#31-数据成员应该限制在7个左右)
    - [3.2. 限制继承的使用](#32-限制继承的使用)

<!-- /TOC -->

首先应该明确的是，为什么要设计一个类：  
* 隔离复杂度
* 隐藏实现细节  
* 提高代码复用

# 1. 如何抽象出ADT

## 1.1. 隐藏并集中化实现细节   

最终目的是将这个类完全拆分出来，可以进行单独的版本升级。比如，一个零件可以被拆下来，换成更好的（可能是更低的成本，更长的使用年限）零件。  
首先，使调用方不需要关注细节，只关注功能；其次，细节被隐藏，意味着被集中在一起，将来如果需要修改，也会更方便，不至于到处寻找需要修改的地方；还有，隐藏细节可以阻止其他程序员(甚至是你自己)去查看额外的底层信息，而这些底层与使用根本是无关的，我们**不应该鼓励(诱惑)其他人去关注无关的细节**。总的来说就是，**更优的逻辑层次和更好的更新体验**。  

## 1.2. 区分底层概念和现实意义   

这一点和上一点有重复。举例说明，在一个字体控制的程序设计中，setFontBold对应着一系列的底层概念上的操作，应该把setFontBold这个现实动作和底层概念区分开。

## 1.3. 减少和其他ADT的关联

尽量把ADT之间的合作限制在较小的范围内。

# 2. 如何设计好接口

## 2.1. 接口的抽象层次应该一致

举例说明。在一个代表雇员表的类中，雇员以链表形式组织，如果有这样的接口：增加、删除雇员，获取链表最后的一个雇员，获取链表最前端的雇员。显然是不协调的，雇员到底如何组织(链表，队列，树等)对于调用者根本不重要，因为调用者已经选择使用了这个类，他不需要再去考虑雇员这个抽象层次以下的细节。

## 2.2. 严格控制成员的可访问性

否则你的类会被其他程序员随意修改！

## 2.3. 不要假设接口的调用顺序

接口之间应该是无关的，它们之间不应该有任何的依赖。**一个具体的接口应该无论其他接口有没有被调用，都能够正常工作下去**。不能有这样的接口：doSomethingA(),doSomethingB(),doSomethingC(),这用彼此依赖的接口根本不能出现。

# 3. 如何设计好成员对象

## 3.1. 数据成员应该限制在7个左右

太多不易于记忆，需要抽象成更小的类。

## 3.2. 限制继承的使用

继承虽然强大，但确实一个比较复杂的特性，需要额外的运行时负担。一般的，只有两层的继承模型是不推荐的；比较推荐的是，类似GUI库中object->abstractWindow->window这样复杂的继承结构。

