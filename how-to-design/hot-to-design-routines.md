<!-- TOC -->

- [1. 为什么要使用子程序(routines)](#1-为什么要使用子程序routines)
    - [1.1. 隔离复杂度，便于维护](#11-隔离复杂度便于维护)
    - [1.2. 引入中间层，隐藏细节](#12-引入中间层隐藏细节)
    - [1.3. 避免代码重复](#13-避免代码重复)
- [2. 如何提高子程序的内聚性](#2-如何提高子程序的内聚性)
    - [2.1. 可取的内聚性](#21-可取的内聚性)
        - [2.1.1. 顺序上的内聚性:子程序内的操作有严格的顺序安排](#211-顺序上的内聚性子程序内的操作有严格的顺序安排)
        - [2.1.2. 通信上的内聚性:子程序内的操作使用的数据来自同一个地方](#212-通信上的内聚性子程序内的操作使用的数据来自同一个地方)
    - [2.2. 不可取的内聚性](#22-不可取的内聚性)
        - [2.2.1. 巧合的内聚性:子程序中的各个操作没有任何明显的关联](#221-巧合的内聚性子程序中的各个操作没有任何明显的关联)
- [3. 如何决定子程序的长度](#3-如何决定子程序的长度)
    - [3.1. 限制在一屏幕左右(50左右)](#31-限制在一屏幕左右50左右)
- [4. 如何使用子程序的参数](#4-如何使用子程序的参数)
    - [4.1. 参数的作用要明显区分输入，输出，修改](#41-参数的作用要明显区分输入输出修改)
    - [4.2. 参数排列有序，输入－修改－输出](#42-参数排列有序输入修改输出)
    - [4.3. 相似的子程序参数排列也要相似](#43-相似的子程序参数排列也要相似)
- [5. 宏的使用](#5-宏的使用)
    - [5.1. 尽量用inline,const等去替代宏](#51-尽量用inlineconst等去替代宏)

<!-- /TOC -->
# 1. 为什么要使用子程序(routines)

## 1.1. 隔离复杂度，便于维护
## 1.2. 引入中间层，隐藏细节
## 1.3. 避免代码重复

# 2. 如何提高子程序的内聚性

经过调查，耦合度与内聚性(cohesion)之比较高的子程序，更容易出现错误。

## 2.1. 可取的内聚性
### 2.1.1. 顺序上的内聚性:子程序内的操作有严格的顺序安排
这样的一系列操作不应该暴露出去，应该聚集在一起，便于debug
### 2.1.2. 通信上的内聚性:子程序内的操作使用的数据来自同一个地方
这里不是很懂。。

## 2.2. 不可取的内聚性
### 2.2.1. 巧合的内聚性:子程序中的各个操作没有任何明显的关联

# 3. 如何决定子程序的长度
## 3.1. 限制在一屏幕左右(50左右)

# 4. 如何使用子程序的参数　　
## 4.1. 参数的作用要明显区分输入，输出，修改
## 4.2. 参数排列有序，输入－修改－输出　　

也可以自己定义IN/OUT说明，```#define IN```，```#define OUT```
## 4.3. 相似的子程序参数排列也要相似

# 5. 宏的使用
## 5.1. 尽量用inline,const等去替代宏