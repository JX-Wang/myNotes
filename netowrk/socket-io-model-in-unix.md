Unix中的5种socket I/O模型
------------

内容来自与<Unix网络编程:卷一>

<!-- TOC -->

- [1. 阻塞式I/O模型](#1-阻塞式io模型)
- [2. 非阻塞式I/O模型](#2-非阻塞式io模型)
- [3. I/O复用模型](#3-io复用模型)
- [4. 信号驱动式I/O模型](#4-信号驱动式io模型)
- [5. 异步I/O模型](#5-异步io模型)

<!-- /TOC -->

这里我们暂时只讨论socket输入的情况,即应用程序通过socket从网络上接受字节.

socket上的输入操作可以分为两个部分:
* 等待数据准备好
* 将数据从内核缓冲区复制到用户进程缓冲区

# 1. 阻塞式I/O模型

所有默认设置的socket都是阻塞的,读数据的流程如下:

* 用户进程调用recv/recvfrom
* (系统调用开始)
* 内核陷入**等待**,直到有数据准备好
* 将数据从内核复制到用户进程
* 复制完成,返回成功标志
* (系统调用结束)
* 用户进程处理数据

整个过程都是阻塞的,recv/recvfrom只在两种情况下返回:
* 数据准备好且被复制到用户进程
* 发生了某些错误

# 2. 非阻塞式I/O模型

可以通过某些设置,**将socket设置成非阻塞**.实际上是在告诉内核:如果所请求的socket I/O操作将把进程陷入睡眠等待的状态,不要陷入睡眠,而是直接返回一个错误标志(EWOULDBLOCK).读数据的流程如下:

* 用户进程调用recv/recvfrom
* (系统调用开始)
* 内核检查是否有数据准备好
    * 如果没有,返回错误标志
    * 如果有,将数据从内核复制到用户进程,返回成功标志
* (系统调用结束)
* 用户进程处理数据

这种IO模型需要反复进行轮询(polling),检查是否有数据准备好,才能成功获取数据.是比较耗费CPU资源的.

# 3. I/O复用模型

IO复用建立在select和polll两个函数之上.select没有复制数据的功能,只用于检查一些socket是否已经准备好,直到有套接子准备好数据复制才返回.以select为例,主要流程如下:

* 用户进程调用select
* (系统调用开始)
* 内核检查多个套接子,是否有数据准备好
    * 如果没有,继续等待,直到有一个套接子准备好
    * 如果有,返回可读条件
* (系统调用结束)
* 用户进程对已经准备好的套接子调用recv/recvfrom
* (系统调用开始)
* 内核将数据复制到用户进程,返回成功标志
* (系统调用结束)
* 用户进程处理数据

这种模型的优势之在于:可以控制多个套接字.但是缺陷也很明显:**需要进行两次系统调用**

# 4. 信号驱动式I/O模型

信号驱动实际上就是中断,当IO数据准备好了(可以进行复制了),内核会发出信号来通知相应的进程.

# 5. 异步I/O模型

同样是一种中断,不过只有当IO操作完成(数据到了用户进程缓冲区),内核才发出信号.
