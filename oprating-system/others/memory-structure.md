# c/c++ 运行时内存结构

## 概述
C/C++内存结构主要分为4种：
* 栈
* 堆
* 可执行文件
* 保留区  

下面是一个**Linux进程**的典型布局：  

|地址|内存区|增长方式|
|----|:----|:----|
|高位（0xffffffff）|内核区||
|......|栈|向下增长|
|......|未使用||
|......|动态链接库映像|地址固定|
|......|未使用||
|......|堆|向上增长|
|......|可执行文件映像||
|......|其他||
|低位（0x00000000）|保留区||

可执行文件映像记录的就是程序的指令。
我们主要关注两个区域：堆和栈。这两个区域在大小、作用等方面都有很大不同。

## 栈
栈是一个比较小的区域，通常只有几M大小。Linux下可以通过limit命令查看栈空间的最大大小：
```shell
ulimit -a
```
我这台机器的大小是8192Kb，也就是8M。
栈是函数调用时使用的重要内存区。栈主要的记录如下内容：
* 函数的返回地址和参数
* 临时变量，也就是非静态局部变量和编译器生成的其他临时变量
* 保存的上下文
上述内容也叫**活动记录**。一个很常见的活动记录(i386下)如下表所示：

|栈|区域中存储的数据|指针|
|:--:|--|--|
|高位|参数||
|^|返回地址||
|^|Old EBP|ebp指针|
|^|保存的寄存器||
|^|局部变量||
|\||其他数据||
|低位|栈顶|esp指针|

函数的调用过程如下：
* 把需要的函数参数压入栈中
* 把当前调用处的下一指令的地址（**返回地址**）压入栈中
* 函数体调用开头
  * 把ebp指针的值压入栈中（Old EBP），也就是记录函数调用方的栈空间，函数调用结束时会返回到该处
  * 初始化栈顶指针esp，此时scp指向ebp，即栈顶
* 执行函数体
  * 这部分包含各种变量的出入栈，甚至有函数调用
* 函数体调用结尾
  * 将esp依次上移，即回收局部变量的内存空间
  * 遇到Old EBP，从栈中回复保存的ebp值，即返回到函数的调用方的栈空间
  * 根据返回地址返回到下一条指令处

注意，这个过程中有两种地址跳转：**栈空间地址跳转和指令地址跳转**。两种跳转分别代表着数据和指令的跳转。所以，每个函数调用时都会有自己的栈空间，即使是函数内部递归调用自己。

这里提一下尾递归的问题。尾递归由于特殊的递归调用位置，没有需要保存的局部变量，所以直接使用当前栈就行。于是编译器就会把递归调用优化成循环，从而减小栈空间的开支。

至于栈空间里的变量是如何被访问的，目前还没有接触到相关资料。

>那么，所谓的”stack overflow”又是什么呢？  
之前说的内存布局中，动态链接映像的地址是固定的，当栈空间不断增长，要增长到动态链接映像区的地址，就会发生溢出现象。“理论上”，存在两种栈溢出：
>* 一个栈的溢出
  如果栈最大只能有8M，那么临时变量太多超出栈的大小，发生溢出。  
  但是这种溢出我从来没遇到过，通过实验也没有发生类似现象。  
>* 多个栈的叠加溢出
  这种情况就很普遍了，通常由于递归调用的层次太深，很容易发生栈溢出。
  我的ubuntu下报错为```Segmentaion fault```    
>
>这种理解是有很大偏差的。**一个进程的内存布局，只有一个栈空间，而不是多个**。可是如果所有的函数使用同一个栈，如何实现变量的作用域？不同函数的变量区域岂不是无法划分？其实，上述的```Old EBP```指针就是为此设计的。这个指针最重要的作用就是实现**跳转功能**，任意时刻，当前栈都可以看成从```Old EBP```开始，当前函数的上一级由于已经跳转（进入当前函数），它的变量存储在当前```Old EBP```之上，运行时环境根据这个指针就可以屏蔽掉之前的局部变量。  
**当然，由于目前没有参考更多的资料，这些只是猜测**。
>
