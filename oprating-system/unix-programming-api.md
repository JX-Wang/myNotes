# 关于socket系列的API

## tips
这里记录一些有关socket的api细节。虽然是参考《UNIX网络编程》，但实际上是在linux环境中实验的（4.4Linux内核中）。

## API
### close()
```cpp
#include <unistd.h>
int close(int fd);
```
这个函数不知应用于socket，它实际上是关闭一个文件描述符。因为unix系统把各种资源都看作是文件来处理（一切皆文件），这个函数因此可以应用到很多地方。它真正做的工作是：  
* **将描述符指向的资源的引用计数减一**   

所以close()并不是真正意义上的释放资源。file-descripter被close后，它不再指向之前的资源（不能再通过这个描述符使用资源）。如果这个file-descripter是最后一个指向该资源的描述符，该资源就会被释放。这个机制更像是java中的垃圾回收机制，和指针很像。套用到socket也就不难理解，被close后的tcp连接不一定会被关闭(发送FIN才算是要关闭)。如果一定要关闭一个tcp连接，应该使用shutdown()函数，它将真正发送一个FIN。  
在开发网络服务器时，这种细节需要特别注意。  
### fork()
```cpp
#include <unistd.h>
pid_t fork(void);
```
fork函数是unix系统中派生新进程的**唯一方法**，当然还有其他的方法，不过都是基于fork函数实现的。这个函数将父进程(称为调用进程，calling process)，派生出一个新进程(称为子进程，child process)。两个进程的内存空间独立分开，互不影响。注意，只有内存空间是完全一样的拷贝，而系统资源有些特殊。一个系统资源只有一个实体，不可能复制，比如tcp连接就不能复制（否则，根据tcp协议一定会出错）。  
父进程调用fork前的**所有已经打开的描述符**在子进程中依然有效，二者共享同一份资源（不是拷贝！）。网络服务器经常是父进程负责打开、关闭资源描述符，子进程负责读写资源。
函数返回值有两种，用来判断当前环境是子进程还是父进程，根据调用这个函数的进程区分：  
* 如果是在**父进程调用fork()**，返回所创建子进程的进程号。  
* 如果是在**子进程调用fork()**，返回0。

那么，这个函数的性能如何呢？虽然fork是唯一的派生新进程方法，不存在替代品，但是由于内存空间的复制拷贝，性能方面是值得考虑的。首先要明确，fork是一个系统调用，系统调用涉及到操作系统内部对任务的优先级选择和一系列的工作，所以它并不像一般的内存区函数调用那样方便，所以它在性能方面具有先天劣势；其次，由于内存空间需要被复制一遍，更加消耗时间和空间。  
> 这里再提一提内存空间的复制。对于内存中的变量复制，是如何复制呢？采用的是默认构造函数，拷贝构造函数，还是复制构造函数？
> 通过objdump，发现汇编后产生的指令直接是一个callq命令，发生了系统调用。
>```assemble
>callq  4005f0 <fork@plt>
>```  
>目前无法看到具体的复制方式。其实，也不存在构造函数的区别。汇编后，变成语言的特性都不在存在。不管是c还是cpp，都是同样的汇编指令。根据猜测，应该是就是简单的按字节复制，根本不存在更多的函数调用。事实上，通过代码实验，并没有出发设置在不同构造函数中的输出语句。因为构造函数的选择应该是编译器做的事情，不会等到程序执行期再选择。

但有一点需要注意，如果涉及到虚拟内存空间，现代操作系统可能会选择出现数据写入内存时才进行内存拷贝。也就是说，子进程有可能和父进程使用同一内存空间。这也是一项优化。
### exec()
```cpp
#include <unistd.h>

extern char **environ;

int execl(const char *path, const char *arg, ...
                /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                /* (char  *) NULL */);
int execle(const char *path, const char *arg, ...
                /*, (char *) NULL, char * const envp[] */);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
                char *const envp[]);
//exec函数指以上的6个函数，它们完成相同任务，不同的只是调用方式不同
```
exec函数具有和fork的特殊性，是unix系统中唯一运行磁盘上的可执行程序的方法。exec函数将当前的进程映像替换成新的程序文件（可联想到linux进程模型中的可执行程序映像区），而且新程序通常由main函数作为入口。注意，内存布局**进程id不会改变**，所以exec不是创建了新进程。exec不是完全改写进程的内存布局，因为调用exec前已打开的资源描述符仍然有效，它们对应的资源没有被回收（这是通常情况下，可以通过一些选项进行设置）。  
exec函数只在出错的时候才返回到调用者的运行环境（出错指程序调用方法的错误，如路径错误、exec本身的参数错误），返回值是-1。  
exec系列函数经常和fork配合使用，用于派生新进程，运行新的程序。  
