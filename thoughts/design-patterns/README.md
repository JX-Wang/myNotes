设计模式
===

这是一篇关于设计模式的学习笔记。内容可能并不深刻，主要意义在于备忘。

本文会对设计模式的主要问题进行概览，再根据面向对象设计需要解决各个问题来讨论设计模式。本文会充斥大段的文字，并且相对抽象。

## 概览

### 什么是设计模式

设计模式是一种面向对象的思想，它主要探讨：**如何设计出可复用的类？**具体设计到如何设计类，以及类之间的交互。前辈们在几十年的时间基础上，总结出一套经验，帮助程序员避免陷入到无止尽的重复设计中，这套经验被总结成一系列的设计模式。

### 设计模式如何分类

要想讨论一种思想，必须理清它内部的脉络。对于设计模式，就是要弄清楚：不同的设计模式之间有什么共性、差异，在应用、效果上有什么优劣不同。后者需要具体到每种设计模式，我们先就前者，对设计模式进行分类。

按照设计模式的**效果**，即它们的用途，可以分为三类：  
* 结构型设计模式，主要讨论类的组织结构，比如一个类如何组织自己，是包含其他类，还是直接继承。 
* 行为型设计模式，主要讨论类的行为方式，比如一个类的状态改变如何影响到其他类，从而协同完成一些任务。  
* 创建型设计模式，主要讨论类对象的创建方式，比如是直接只用类型关键字来创建对象，还是设计复杂的方法，在这个方法里完成一系列的初始化动作。  

按照设计模式的**作用对象**,分为两类：  
* 作用于类，即是处理类和子类之间的关系，主要包含静态的继承。
* 作用与对象，即使处理不同对象之间的关系，主要包含动态的交互方式。

### 类(class)和类型(type)的区别

对象具有类和类型两个属性，对象的类定义、实现了对象的结构和接口，类型则只定义好了对象的接口。可以联想到Golang中的面向对象，只要一个对象满足某些接口，就可以说他是某种类型。

### 针对接口编程，而不是针对实现编程

这一点对我的触动特别大。

直到现在，我还处在针对实现编程的阶段。设计一个类时，我总是把它支持的操作理出来，杂糅到类的定义里。这样一来，我只关注了这个类具有什么操作，如何组织成员变量从而实现这些操作，但**没有关注操作之间的关系，以及操作和其他类的关系**。这样说可能很费解，如果这个类中的某些方法，在其他类中也出现了，那么是不是应该把他们抽象出来进行复用呢？很显然，我在设计类时，没有考虑这个问题，所以类的复用仅限于调用接口，一旦出现了类似的类，就不得不再实现整个方法集合。

所谓面对接口编程，就是**提倡让对象遵从某些接口，而不是让对象成为某种具体的类的实例**。前者能够减轻模块之间的耦合，因为**上下游不用关心双方间的交互对象到底是属于什么类，只需要知道这个对象能够提供哪些接口**。这里就是在讨论继承的作用了，我们不管指针到底指向什么类的实例，我们只需要知道，通过这个指针我们能获得哪些操作。

### 聚合与相识

聚合是指，**类对自己的成员变量负责，它拥有这个变量，关注变量的状态变化**。二者的生命周期几乎相同，存在很强的耦合关系。

相识是指，**类只是认识自己的成员变量，但不拥有这个变量，只需要调用它的接口**。二者的生命周期不同，类可以随时替换一个新的成员变量，只要新成员变量能够满足接口约定，而不必为成员变量执行构造/析构操作，耦合关系相对聚合要弱。

就代码的语法层次而言，聚合与相识是很难区分的。他们的区别更多的体现在代码实现。这一点可能看起来不怎么实用，但在编码时，还是常常会体会到二者带来的不同设计思想。

### 应用，类库和框架

现在来讨论设计模式对于三种软件的作用：

* 应用。应用的复用性主要在于应用内部，我们并不期待这个应用可以直接用于将来的某个需求，而仅仅要求能满足当前的业务场景。**设计模式主要靠减小耦合，从而提高应用内部的复用，减少设计、代码量**。我们使用设计模式来孤立、封装一个操作，使它在各种场景下都可以被直接使用，并且不依赖或很少依赖于其他组件。
* 类库。不同于应用，类库更多的强调灵活性。它更加关注基础设施的构建，比如一些数据结构、算法、IO操作，都属于类库提供的典型功能。
* 框架。框架规定了应用的体系结构。比如，在一个web应用中，框架规定了你在哪个概念里实现url设计，在哪个概念里实现数据库操作等。框架限制了应用在代码上的表现形式，使得我们只需要填充这个框架的细节，而不用重新设计系统的概念层次，**这将大大减少我们需要作出的设计决策**。

## 如何寻找合适的对象

通常，我们针对某个行为，写出一个主谓宾结构的句子。句子的主语、谓语、宾语都可以成为一个对象。这里的主谓宾可能比较明显，但往往存在一些不明显的概念，也需要设计成对象。设计模式可以帮我们确定并不明显的抽象，并提供一些对象来描述这些抽象。

### Composite模式

### Strategy模式

### State模式